name: Enrich EPG with TVmaze & Trakt

on:
  schedule:
    - cron: '10 0 * * *'
  workflow_dispatch:

jobs:
  enrich:
    runs-on: ubuntu-latest

    env:
      TRAKT_CLIENT_ID: ${{ secrets.TRAKT_CLIENT_ID }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: pip install lxml requests fuzzywuzzy[speedup]

      - name: Enrich XMLs with TVmaze + Trakt fallback
        run: |
          python3 - <<'EOF'
          import os
          import re
          import time
          import glob
          import requests
          from lxml import etree
          from fuzzywuzzy import fuzz

          TRAKT_CLIENT_ID = os.getenv("TRAKT_CLIENT_ID")

          def normalize(text):
              return re.sub(r'\W+', ' ', text or '').strip().lower()

          def fuzzy_match(title, desc, episodes, min_score=65):
              input_text = normalize(f"{title} {desc}")
              for ep in episodes:
                  overview = ep.get("summary") or ep.get("overview") or ""
                  score = fuzz.partial_ratio(input_text, normalize(f"{title} {overview}"))
                  if score >= min_score:
                      return ep
              return None

          def fetch_tvmaze(title, cache):
              if title in cache:
                  return cache[title]
              try:
                  r = requests.get(f"https://api.tvmaze.com/singlesearch/shows?q={title}&embed=episodes", timeout=10)
                  if r.status_code == 200:
                      data = r.json()
                      eps = data["_embedded"]["episodes"]
                      cache[title] = eps
                      time.sleep(0.5)
                      return eps
              except Exception as e:
                  print(f"TVmaze error for '{title}': {e}")
              cache[title] = []
              return []

          headers = {
              "Content-Type": "application/json",
              "trakt-api-version": "2",
              "trakt-api-key": TRAKT_CLIENT_ID,
          }

          def fetch_trakt_show(title):
              try:
                  r = requests.get(f"https://api.trakt.tv/search/show?query={title}&limit=1", headers=headers, timeout=10)
                  if r.status_code == 200 and r.json():
                      return r.json()[0]["show"]
              except Exception as e:
                  print(f"Trakt show search failed: {e}")
              return None

          def fetch_trakt_episodes(slug):
              try:
                  url = f"https://api.trakt.tv/shows/{slug}/seasons?extended=episodes"
                  r = requests.get(url, headers=headers, timeout=10)
                  if r.status_code == 200:
                      data = r.json()
                      eps = []
                      for s in data:
                          if s["number"] == 0:  # skip specials
                              continue
                          eps.extend(s.get("episodes", []))
                      return eps
              except Exception as e:
                  print(f"Trakt episodes fetch failed for {slug}: {e}")
              return []

          def fetch_trakt_movie(title):
              try:
                  r = requests.get(f"https://api.trakt.tv/search/movie?query={title}&limit=1", headers=headers, timeout=10)
                  if r.status_code == 200 and r.json():
                      return r.json()[0]["movie"]
              except Exception as e:
                  print(f"Trakt movie search failed: {e}")
              return None

          cache_tvmaze = {}

          for xml_file in glob.glob("individual/*.xml"):
              print(f"\nüìÑ Processing {xml_file}")
              parser = etree.XMLParser(recover=True)
              tree = etree.parse(xml_file, parser)
              root = tree.getroot()

              for prog in root.findall("programme"):
                  title_el = prog.find("title")
                  desc_el = prog.find("desc")
                  if title_el is None or desc_el is None:
                      continue

                  title = title_el.text.strip()
                  desc = desc_el.text.strip()

                  # Skip if already enriched
                  existing = prog.xpath("episode-num[@system='tvmaze-matched' or @system='trakt-matched']")
                  if existing:
                      continue

                  # === TVmaze Match ===
                  episodes = fetch_tvmaze(title, cache_tvmaze)
                  best_ep = fuzzy_match(title, desc, episodes)

                  if best_ep:
                      season = best_ep.get("season")
                      episode = best_ep.get("number")
                      ep_title = best_ep.get("name", "")
                      airdate = best_ep.get("airdate")

                      etree.SubElement(prog, "episode-num", system="tvmaze-matched").text = f"{season - 1}.{episode}.0"
                      sub = prog.find("sub-title") or etree.SubElement(prog, "sub-title", lang="en")
                      sub.text = ep_title
                      if airdate:
                          date_tag = prog.find("date") or etree.SubElement(prog, "date")
                          date_tag.text = airdate.replace("-", "")
                      print(f"‚úÖ TVmaze: {title} -> S{season:02}E{episode:02} ‚Äî '{ep_title}'")
                      continue

                  # === Trakt Episodes Fallback ===
                  trakt_show = fetch_trakt_show(title)
                  if trakt_show:
                      slug = trakt_show["ids"]["slug"]
                      episodes = fetch_trakt_episodes(slug)
                      best_ep = fuzzy_match(title, desc, episodes)
                      if best_ep:
                          season = best_ep.get("season")
                          episode = best_ep.get("number")
                          ep_title = best_ep.get("title", "")
                          airdate = best_ep.get("first_aired")

                          etree.SubElement(prog, "episode-num", system="trakt-matched").text = f"{season - 1}.{episode}.0"
                          sub = prog.find("sub-title") or etree.SubElement(prog, "sub-title", lang="en")
                          sub.text = ep_title
                          if airdate:
                              date_tag = prog.find("date") or etree.SubElement(prog, "date")
                              date_tag.text = airdate[:10].replace("-", "")
                          print(f"üì∫ Trakt: {title} -> S{season:02}E{episode:02} ‚Äî '{ep_title}'")
                          continue

                  # === Trakt Movie Fallback ===
                  trakt_movie = fetch_trakt_movie(title)
                  if trakt_movie:
                      year = trakt_movie.get("year")
                      released = trakt_movie.get("released")
                      movie_title = trakt_movie.get("title", title)

                      etree.SubElement(prog, "episode-num", system="trakt-matched").text = "0.0.0"
                      sub = prog.find("sub-title") or etree.SubElement(prog, "sub-title", lang="en")
                      sub.text = movie_title
                      if released:
                          date_tag = prog.find("date") or etree.SubElement(prog, "date")
                          date_tag.text = released[:10].replace("-", "")
                      # Add category tag for movies
                      cat_el = etree.SubElement(prog, "category", lang="en")
                      cat_el.text = "movie"

                      print(f"üé¨ Trakt Movie: {title} -> '{movie_title}' ({year})")
                      continue

                  print(f"‚ö†Ô∏è  No match found for: {title}")

              tree.write(xml_file, encoding="utf-8", xml_declaration=True)
          EOF

      - name: Commit changes
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "actions@github.com"
          git add individual/*.xml
          git diff --cached --quiet || (git commit -m "Enriched EPG with metadata and movie categorization" && git push)
