name: Enrich and Split EPG by Channel

on:
  workflow_dispatch:
  schedule:
    - cron: '25 3 * * *'

jobs:
  enrich-epg:
    runs-on: ubuntu-latest

    steps:
      $1

      - name: Set up Git identity
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "actions@github.com"

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          pip install requests lxml fuzzywuzzy python-Levenshtein

      - name: Enrich and Split EPG
        env:
          TRAKT_CLIENT_ID: ${{ secrets.TRAKT_CLIENT_ID }}
          GITHUB_WORKSPACE: ${{ github.workspace }}
        run: |
          cat << 'EOF' > enrich_split_push.py
          import requests
          from lxml import etree
          import re
          import os
          import subprocess
          import time
          from fuzzywuzzy import fuzz
          from collections import defaultdict

          HEADERS = {
              "trakt-api-key": os.getenv("TRAKT_CLIENT_ID"),
              "trakt-api-version": "2"
          }

          SHOWS = {
              "mjh-10-south-park": "South Park",
              # Extend with other channel:show pairs
          }

          def git_commit_and_push(file_path, msg):
              try:
                  subprocess.run(["git", "add", file_path], check=True)
                  subprocess.run(["git", "commit", "-m", msg], check=True)
                  subprocess.run(["git", "pull", "--rebase", "--autostash"], check=True)
                  subprocess.run(["git", "push"], check=True)
              except subprocess.CalledProcessError as e:
                  print("Git error:", e)

          def parse_title(title):
              title = title.strip()
              m = re.search(r"S(\d+)\s*Ep\.?\s*(\d+)", title, re.IGNORECASE)
              if m:
                  return int(m.group(1)), int(m.group(2))
              m = re.search(r"S(\d+)\s*E(\d+)", title, re.IGNORECASE)
              if m:
                  s = int(m.group(1))
                  e_str = m.group(2)
                  e = int(e_str[len(str(s)):] if e_str.startswith(str(s)) else e_str)
                  return s, e
              return None, None

          def get_tvmaze_data(show, s, e):
              try:
                  time.sleep(0.5)
                  r = requests.get(f"https://api.tvmaze.com/singlesearch/shows?q={show}&embed=episodes")
                  r.raise_for_status()
                  j = r.json()
                  for ep in j['_embedded']['episodes']:
                      if ep['season'] == s and ep['number'] == e:
                          return {
                              "title": ep['name'],
                              "season": s,
                              "episode": e,
                              "genres": j.get("genres", []),
                              "rating": j.get("rating", {}).get("average"),
                              "airdate": ep.get("airdate")
                          }
              except: pass
              return None

          def get_trakt_movies(title):
              try:
                  time.sleep(0.5)
                  r = requests.get(f"https://api.trakt.tv/search/movie?query={title}", headers=HEADERS)
                  r.raise_for_status()
                  return r.json()
              except: return []

          def enrich_movie(prog, title):
              movies = get_trakt_movies(title)
              best = max(movies, key=lambda m: fuzz.ratio(title.lower(), m['movie']['title'].lower()), default=None)
              if best and fuzz.ratio(title.lower(), best['movie']['title'].lower()) >= 85:
                  prog.find('title').text = best['movie']['title']
                  etree.SubElement(prog, "category").text = "Movie"
                  for g in best['movie'].get('genres', []):
                      etree.SubElement(prog, "category").text = g.title()
                  if best['movie'].get("released"):
                      etree.SubElement(prog, "episode-num", system="original-air-date").text = best['movie']['released']
                  return True
              return False

          def enrich(prog):
              if prog.find('desc') is not None:
                  return
              channel = prog.get('channel')
              title_elem = prog.find('title')
              raw_title = title_elem.text if title_elem is not None else ""
              show = SHOWS.get(channel)
              if show and show.lower() in raw_title.lower():
                  s, e = parse_title(raw_title)
                  if not s or not e:
                      return
                  data = get_tvmaze_data(show, s, e)
                  if not data:
                      enrich_movie(prog, raw_title)
                      return
                  title_elem.text = show
                  sub = prog.find("sub-title") or etree.SubElement(prog, "sub-title", lang="en")
                  sub.text = f"{data['title']} - S{data['season']:02d}E{data['episode']:02d}"
                  for tag in prog.findall("category"): prog.remove(tag)
                  for g in data.get("genres", []):
                      etree.SubElement(prog, "category").text = g.title()
                  if data.get("airdate"):
                      etree.SubElement(prog, "episode-num", system="original-air-date").text = data['airdate']
              else:
                  enrich_movie(prog, raw_title)

          def main():
              url = "https://raw.githubusercontent.com/matthuisman/i.mjh.nz/refs/heads/master/au/Sydney/epg.xml"
              tree = etree.fromstring(requests.get(url).content)
              grouped = defaultdict(list)
              for prog in tree.findall(".//programme"):
                  enrich(prog)
                  grouped[prog.get("channel")].append(prog)
              out_base = os.path.join(os.getenv("GITHUB_WORKSPACE", "."), "Backflow", "Manual_Database")
              os.makedirs(out_base, exist_ok=True)
              for chan, progs in grouped.items():
                  root = etree.Element("tv")
                  for p in progs:
                      root.append(p)
                  path = os.path.join(out_base, f"{chan}.xml")
                  with open(path, "wb") as f:
                      f.write(etree.tostring(root, pretty_print=True, encoding="UTF-8"))
                  print("Wrote:", path)
                  git_commit_and_push(path, f"Update EPG for {chan}")

          if __name__ == "__main__":
              main()
          EOF

          python enrich_split_push.py

      - name: Show output
        run: ls -al Backflow/Manual_Database/
