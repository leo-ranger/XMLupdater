name: Update EPG XML South Park (Australia)

on:
  schedule:
    - cron: '0 0 * * *'  # Daily at midnight UTC
  workflow_dispatch:

jobs:
  enrich-epg:
    runs-on: ubuntu-latest
    env:
      TRAKT_CLIENT_ID: ${{ secrets.TRAKT_CLIENT_ID }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Create output folder if it doesn't exist
        run: mkdir -p Backflow/Manual_Database

      - name: Download South Park EPG XML
        run: |
          curl -o Backflow/Manual_Database/AU-South_Park.xml "https://epg.pw/api/epg.xml?lang=en&date=$(date +%Y%m%d)&channel_id=105810"

      - name: Enrich EPG XML with TVmaze and Trakt and fix channel IDs
        run: |
          python3 - <<'EOF'
          import xml.etree.ElementTree as ET
          import requests, time, re, os

          TVMAZE_SHOW_ID = 112
          INPUT_XML = "Backflow/Manual_Database/AU-South_Park.xml"
          OUTPUT_XML = "Backflow/Manual_Database/AU-South_Park.xml"
          FIXED_ICON = "https://tendaily-prod-images.s3.ap-southeast-2.amazonaws.com/2020/09/18/9af150a4ebd91350a4713fa737952a1d-993431.jpg"
          TRAKT_CLIENT_ID = os.environ['TRAKT_CLIENT_ID']

          def get_tvmaze_episode(season, episode):
              url = f"https://api.tvmaze.com/shows/{TVMAZE_SHOW_ID}/episodebynumber?season={season}&number={episode}"
              try:
                  r = requests.get(url)
                  if r.status_code == 200:
                      time.sleep(1.5)
                      return r.json()
              except: pass
              time.sleep(1.5)
              return None

          def get_trakt_episode(season, episode):
              headers = {
                  'Content-Type': 'application/json',
                  'trakt-api-version': '2',
                  'trakt-api-key': TRAKT_CLIENT_ID
              }
              url = f"https://api.trakt.tv/shows/south-park/seasons/{season}/episodes/{episode}?extended=full"
              try:
                  r = requests.get(url, headers=headers)
                  if r.status_code == 200:
                      time.sleep(1.5)
                      return r.json()
              except: pass
              time.sleep(1.5)
              return None

          def safe_get_episode(season, episode):
              if episode <= 20:
                  return episode
              if get_tvmaze_episode(season, episode):
                  return episode
              season_str = str(season)
              ep_str = str(episode)
              if len(ep_str) > len(season_str):
                  fixed = ep_str[len(season_str):]
                  if fixed.isdigit() and get_tvmaze_episode(season, int(fixed)):
                      return int(fixed)
              return episode

          def strip_html(text):
              return re.sub('<[^<]+?>', '', text or '')

          tree = ET.parse(INPUT_XML)
          root = tree.getroot()
          title_re = re.compile(r"South Park S(\d+) Ep\. (\d+)", re.IGNORECASE)

          for prog in root.findall('programme'):
              # Fix the channel id here
              prog.set('channel', 'mjh-10-south-park')

              title_el = prog.find('title')
              if title_el is None or not title_el.text:
                  continue
              match = title_re.match(title_el.text.strip())
              if not match:
                  continue

              season = int(match.group(1))
              episode = int(match.group(2))
              episode = safe_get_episode(season, episode)
              ep_data = get_tvmaze_episode(season, episode)
              fallback = get_trakt_episode(season, episode) if not ep_data else None

              ep_name = ep_data.get('name') if ep_data else fallback.get('title') if fallback else 'Unknown Episode'
              genres = ep_data.get('genres') if ep_data else fallback.get('genres') if fallback else []
              summary = ep_data.get('summary') if ep_data else fallback.get('overview') if fallback else ''
              airdate = ep_data.get('airdate') if ep_data else fallback.get('first_aired') if fallback else None
              rating = fallback.get('rating', {}).get('value') if fallback and fallback.get('rating') else None

              title_el.text = "South Park"

              # Remove existing tags to avoid duplicates
              for tag in ['sub-title', 'category', 'desc', 'icon', 'rating', 'date']:
                  for el in prog.findall(tag):
                      prog.remove(el)

              # Add sub-title
              ET.SubElement(prog, 'sub-title').text = f"{ep_name} - S{season} Ep. {episode}"

              # Add fixed genres + those from data
              for genre in set(genres or []) | {"Comedy", "Animation"}:
                  cat = ET.SubElement(prog, 'category', {'lang': 'en'})
                  cat.text = genre

              # Add description
              if summary:
                  ET.SubElement(prog, 'desc').text = strip_html(summary)

              # Remove old <date> tags and add new
              for date_elem in prog.findall('date'):
                  prog.remove(date_elem)
              if airdate:
                  ET.SubElement(prog, 'date').text = airdate[:10]

              # Add rating
              if rating:
                  r = ET.SubElement(prog, 'rating', {'system': 'Trakt'})
                  r.text = f"{rating:.1f}"

              # Add fixed icon
              ET.SubElement(prog, 'icon', {'src': FIXED_ICON})

          tree.write(OUTPUT_XML, encoding='utf-8', xml_declaration=True)
          EOF

      - name: Commit and push changes
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "actions@github.com"
          git add Backflow/Manual_Database/AU-South_Park.xml
          git commit -m "Updated South Park EPG $(date +%Y-%m-%d)" || echo "No changes to commit"
          git pull --rebase --autostash
          git push
