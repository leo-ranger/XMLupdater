name: Merge Metadata into AU EPG

on:
  schedule:
    - cron: '0 0 * * *'  # Daily at midnight UTC
  workflow_dispatch:

jobs:
  merge-epg:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Create required folders
        run: |
          mkdir -p Backflow
          mkdir -p Backflow/Manual_Database
          mkdir -p Master_Location

      - name: Download base Sydney EPG
        run: |
          curl -o Backflow/base_au_epg.xml "https://raw.githubusercontent.com/matthuisman/i.mjh.nz/refs/heads/master/au/Sydney/epg.xml"

      - name: Merge enriched metadata from all sources
        run: |
          python3 - <<'EOF'
import xml.etree.ElementTree as ET
import re, os, glob, sys
sys.path.insert(0, 'Backflow/scripts')
from A_episode_corrector import correct_episode_number

base_epg_path = 'Backflow/base_au_epg.xml'
enriched_dir = 'Backflow/Manual_Database'
output_path = 'Master_Location/combined_epg.xml'

def extract_season_episode(text):
    match = re.search(r"S(\d+)\s*Ep\.?\s*(\d+)", text, re.IGNORECASE)
    if not match:
        return None, None
    season = int(match.group(1))
    episode = int(match.group(2))
    episode = correct_episode_number(season, episode)
    return season, episode

def build_enriched_map():
    lookup = {}
    for path in glob.glob(f"{enriched_dir}/*.xml"):
        try:
            tree = ET.parse(path)
            root = tree.getroot()
            for prog in root.findall('programme'):
                sub = prog.find('sub-title')
                if sub is not None and sub.text:
                    season, episode = extract_season_episode(sub.text)
                    if season and episode:
                        lookup[(season, episode)] = prog
        except Exception as e:
            print(f"Error reading {path}: {e}")
    return lookup

def enrich_base_epg():
    base_tree = ET.parse(base_epg_path)
    base_root = base_tree.getroot()
    enriched_map = build_enriched_map()

    for prog in base_root.findall('programme'):
        title = (prog.findtext('title') or '').lower()
        channel = prog.get('channel')
        if channel != prog.attrib.get('channel'):
            continue

        sub = prog.find('sub-title')
        raw_text = sub.text if sub is not None and sub.text else ''
        season, episode = extract_season_episode(raw_text)

        if not season or not episode:
            title_el = prog.find('title')
            if title_el is None:
                continue
            season, episode = extract_season_episode(title_el.text)

        if not season or not episode:
            continue

        enriched_prog = enriched_map.get((season, episode))
        if not enriched_prog:
            continue

        title_el = prog.find('title')
        if title_el is not None:
            title_el.text = "South Park"

        for tag in ['sub-title', 'desc', 'category', 'icon', 'rating', 'date']:
            for el in prog.findall(tag):
                prog.remove(el)

        for tag in ['sub-title', 'desc', 'icon', 'rating', 'date']:
            el = enriched_prog.find(tag)
            if el is not None:
                new_el = ET.Element(tag, el.attrib)
                new_el.text = el.text
                prog.append(new_el)

        for cat in enriched_prog.findall('category'):
            new_cat = ET.Element('category', cat.attrib)
            new_cat.text = cat.text
            prog.append(new_cat)

    base_tree.write(output_path, encoding='utf-8', xml_declaration=True)

enrich_base_epg()
EOF

      - name: Commit and push merged EPG
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "actions@github.com"
          git add Master_Location/combined_epg.xml
          git commit -m "Merged metadata into AU EPG $(date +%Y-%m-%d)" || echo "No changes to commit"
          git pull --rebase --autostash
          git push
